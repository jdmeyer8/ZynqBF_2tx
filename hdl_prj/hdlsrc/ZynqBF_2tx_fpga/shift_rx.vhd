-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\shift_rx.vhd
-- Created: 2019-02-08 13:29:43
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: shift_rx
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/peakdetect_ch1/correlator1/shift_rx
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ZynqBF_2tx_fpga_pkg.ALL;

ENTITY shift_rx IS
  PORT( 
        clk:                                in std_logic;
        reset:                              in std_logic;
        u                                 :   IN    vector_of_std_logic_vector16(0 TO 63);  -- sfix16_En15 [64]
        shift                             :   IN    std_logic_vector(5 DOWNTO 0);  -- ufix6
        y                                 :   OUT   vector_of_std_logic_vector16(0 TO 63)  -- sfix16_En15 [64]
        );
END shift_rx;


ARCHITECTURE rtl OF shift_rx IS

  -- Signals
  SIGNAL u_signed                         : vector_of_signed16(0 TO 63);  -- sfix16_En15 [64]
  SIGNAL shift_unsigned                   : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL y_tmp                            : vector_of_signed16(0 TO 63);  -- sfix16_En15 [64]
  --signal shifti:                            integer range 0 to 63;

BEGIN

shift_proc: process(clk,reset)
begin
  if clk'event and clk = '1' then
    if reset = '1' then
        for i in 0 to 63 loop
          y(i) <= x"0000";
        end loop;
    else
        if shift = "000000" then
            y <= u;
        else
            y(0 to (63 - to_integer(unsigned(shift)))) <= u(to_integer(unsigned(shift)) to 63);
            y((64-to_integer(unsigned(shift))) to 63) <= u(0 to (to_integer((unsigned(shift))) - 1));
        end if;
    end if;
  end if;
end process;

  -- outputgen1: FOR k1 IN 0 TO 63 GENERATE
    -- u_signed(k1) <= signed(u(k1));
  -- END GENERATE;

  -- shift_unsigned <= unsigned(shift);

  -- shift_rx_1_output : PROCESS (shift_unsigned, u_signed)
    -- VARIABLE ns : signed(31 DOWNTO 0);
    -- VARIABLE shiftright : std_logic;
    -- VARIABLE a : vector_of_signed16(0 TO 63);
    -- VARIABLE unusedU0 : vector_of_signed16(0 TO 31);
    -- VARIABLE cast : signed(31 DOWNTO 0);
    -- VARIABLE cast_0 : signed(32 DOWNTO 0);
    -- VARIABLE cast_1 : signed(7 DOWNTO 0);
    -- VARIABLE cast_2 : signed(31 DOWNTO 0);
    -- VARIABLE cast_3 : signed(32 DOWNTO 0);
    -- VARIABLE cast_4 : signed(7 DOWNTO 0);
    -- VARIABLE cast_5 : signed(32 DOWNTO 0);
  -- BEGIN
    -- --MATLAB Function 'channel_estimator/peakdetect_ch1/correlator1/shift_rx'
    -- -- y = zeros(64,1,'like',u);
    -- cast := signed(resize(shift_unsigned, 32));
    -- cast_0 :=  - (resize(cast, 33));
    -- cast_1 := cast_0(7 DOWNTO 0);
    -- IF cast_1 < to_signed(16#00000000#, 8) THEN 
      -- cast_2 := signed(resize(shift_unsigned, 32));
      -- cast_3 :=  - (resize(cast_2, 33));
      -- cast_4 := cast_3(7 DOWNTO 0);
      -- cast_5 :=  - (resize(cast_4, 33));
      -- ns := cast_5(31 DOWNTO 0);
      -- shiftright := '0';
    -- ELSE 
      -- ns := to_signed(16#00000000#, 32);
      -- shiftright := '1';
    -- END IF;
    -- IF ns > to_signed(16#00000020#, 32) THEN 
      -- ns := 64 - ns;
      -- shiftright :=  NOT shiftright;
    -- END IF;
    -- unusedU0 := (OTHERS => to_signed(16#0000#, 16));
    -- a := u_signed;
    -- IF ns > to_signed(16#00000000#, 32) THEN 
      -- IF shiftright = '1' THEN 

        -- FOR k_4 IN 0 TO 31 LOOP
          -- IF to_signed(k_4 + 1, 32) <= ns THEN 
            -- unusedU0(k_4) := u_signed(to_integer((to_signed(k_4, 32) - ns) + 64));
          -- END IF;
        -- END LOOP;


        -- FOR k_3 IN 62 DOWNTO 0 LOOP
          -- IF to_signed(k_3 + 2, 32) >= (ns + 1) THEN 
            -- a(k_3 + 1) := a(to_integer((to_signed(k_3, 32) - ns) + 1));
          -- END IF;
        -- END LOOP;


        -- FOR k_2 IN 0 TO 31 LOOP
          -- IF to_signed(k_2 + 1, 32) <= ns THEN 
            -- a(k_2) := unusedU0(k_2);
          -- END IF;
        -- END LOOP;

      -- ELSE 

        -- FOR k_1 IN 0 TO 31 LOOP
          -- IF to_signed(k_1 + 1, 32) <= ns THEN 
            -- unusedU0(k_1) := u_signed(k_1);
          -- END IF;
        -- END LOOP;


        -- FOR k_0 IN 0 TO 62 LOOP
          -- IF to_signed(k_0 + 1, 32) <= (64 - ns) THEN 
            -- a(k_0) := a(to_integer(to_signed(k_0, 32) + ns));
          -- END IF;
        -- END LOOP;


        -- FOR k IN 0 TO 31 LOOP
          -- IF to_signed(k + 1, 32) <= ns THEN 
            -- a(to_integer((to_signed(k, 32) - ns) + 64)) := unusedU0(k);
          -- END IF;
        -- END LOOP;

      -- END IF;
    -- END IF;
    -- y_tmp <= a;
  -- END PROCESS shift_rx_1_output;


  -- outputgen: FOR k1 IN 0 TO 63 GENERATE
    -- y(k1) <= std_logic_vector(y_tmp(k1));
  -- END GENERATE;
  
  

END rtl;

