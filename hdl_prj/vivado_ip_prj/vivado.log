#-----------------------------------------------------------
# Vivado v2017.4 (64-bit)
# SW Build 2086221 on Fri Dec 15 20:54:30 MST 2017
# IP Build 2085800 on Fri Dec 15 22:25:07 MST 2017
# Start of session at: Tue Jan 15 11:07:18 2019
# Process ID: 31040
# Current directory: /home/jason/matlab/Projects/hdl_prj/vivado_ip_prj
# Command line: vivado -mode batch -source vivado_update_prj.tcl
# Log file: /home/jason/matlab/Projects/hdl_prj/vivado_ip_prj/vivado.log
# Journal file: /home/jason/matlab/Projects/hdl_prj/vivado_ip_prj/vivado.jou
#-----------------------------------------------------------
source vivado_update_prj.tcl
# open_project vivado_prj.xpr
Scanning sources...
Finished scanning sources
INFO: [IP_Flow 19-234] Refreshing IP repositories
INFO: [IP_Flow 19-1700] Loaded user IP repository '/home/jason/matlab/Projects/hdl_prj/vivado_ip_prj/ipcore'.
WARNING: [IP_Flow 19-3685] Ignored loading user repository '/home/jason/matlab/Projects/hdl_prj/vivado_ip_prj/ipcore/adi/library'. The path is contained within another repository.
INFO: [IP_Flow 19-2313] Loaded Vivado IP repository '/opt/Xilinx/Vivado/2017.4/data/ip'.
# set boardName {zc706}
# set project {fmcomms2}
# set mw_hdl_dir {ipcore/mw}
# set ad_hdl_dir {ipcore/adi}
# set variant {rx}
# source vivado_custom_update_prj.tcl
## set thisDir [file normalize [file dirname [info script]]]
## if { ! [info exists mw_hdl_dir] } {
##     set mw_hdl_dir ${thisDir}/ipcore/mw
## }
## source $mw_hdl_dir/common/scripts/xilinx/mw_project.tcl
### proc mw_project_create {project_name {boardName_in ""}} {
### 
###     if {$boardName_in == ""} {
###         puts "==> Deriving board name from project name"    
###         if [regexp "_zed$" $project_name] {
###             set boardName_in "zed"
###         }
###         if [regexp "_zc702$" $project_name] {
###             set boardName_in "zc702"
###         }
###         if [regexp "_zc706$" $project_name] {
###             set boardName_in "zc706"
###         }
### 
###         if [regexp "_uzed_7020$" $project_name] {
###             set boardName_in "uzed7020"
###         }
### 
###         if [regexp "_uzed_7010$" $project_name] {
###             set boardName_in "uzed7010"
###         }
###     
###         if [regexp "_mmp100$" $project_name] {
###             set boardName_in "mmp100"
###         }
###         
###         if [regexp "_mmp045$" $project_name] {
###             set boardName_in "mmp045"
###         }
### 
###         puts "==> Setting board name to $boardName_in"
###     }
### 
###     mw_load_board_tcl $boardName_in
###     mw_set_board_info $boardName_in
###     mw_init_project $project_name
###     mw_setup_libs
###     mw_config_project  
### }
### proc mw_config_project {} {
###     set buildAny [expr [mw_get_build_target "handoff"] || [mw_get_build_target "fsbl"]]
###     switch [mw_project_get cpu_type] {
###         kintex7_pcie {
###             mw_set_build_target "fsbl" 0
###             mw_set_build_target "handoff" 0
###         }
###         zynqmp_arm {
###            mw_set_build_target "fsbl" 0
###            mw_set_build_target "handoff" $buildAny
###            mw_project_set xsdk_proc "mw_create_zynqmp_fsbl"
###            mw_project_set xsdk_binaries [list fsbl/executable.elf pmufw/executable.elf pmufw/executable.bin]
###         }
###         zynq7_arm {
###            mw_set_build_target "fsbl" 0
###            mw_set_build_target "handoff" $buildAny
###            mw_project_set xsdk_proc "mw_create_zynq_fsbl"
###            mw_project_set xsdk_binaries [list fsbl/executable.elf]
###         }
###     }
### }
### proc mw_project_set {configItem value} {
###     global mw_project_info
###     if { ![info exists mw_project_info] } {
###         set mw_project_info [dict create]
###     }
###     
###     dict set mw_project_info $configItem $value
### }
### proc mw_project_get {configItem} {
###     global mw_project_info
###     if { ![info exists mw_project_info] } {
###         return ""
###     }
###     if { [dict exists $mw_project_info $configItem] } {
###         return [dict get $mw_project_info $configItem]
###     } else {
###         return ""
###     }
### }
### proc mw_set_board_info {boardName_in} {
###     # defaults
###     mw_project_set "mw_ip_baseaddr" 0x40010000
###     mw_project_set "boardName" $boardName_in 
###     mw_project_set "cpu_type" "zynq7_arm"
### 
###     if { [info procs board_set_board_info] == "board_set_board_info" } {
###         board_set_board_info
###     } else {
###         switch $boardName_in {
###             zed {
###                 mw_project_set project_part "xc7z020clg484-1"
###                 mw_project_set project_board "em.avnet.com:zed:part0:1.0"
###                 mw_project_set mw_ip_baseaddr 0x400D0000
###             }
###             zc702 {
###                 mw_project_set project_part "xc7z020clg484-1"
###                 mw_project_set project_board "xilinx.com:zc702:part0:1.0"
###             }
###             zc706 {
###                 mw_project_set project_part "xc7z045ffg900-2"
###                 mw_project_set project_board "xilinx.com:zc706:part0:1.0"
###             }
### 
###             uzed7020 {
###                 mw_project_set project_part "xc7z020clg400-1"
###                 mw_project_set project_board "em.avnet.com:MicroZed_7020:part0:1.0"
###             }
### 
###             uzed7010 {
###                 mw_project_set project_part "xc7z010clg400-1"
###                 mw_project_set project_board "em.avnet.com:MicroZed_7010:part0:1.1"
###             }
### 
###             mmp100 {
###                 mw_project_set project_part "xc7z100ffg900-2"
###                 mw_project_set project_board "em.avnet.com:mini_module_plus_7z100_rev_c:part0:1.0"
###             }
### 
###             mmp045 {
###                 mw_project_set project_part "xc7z045ffg900-1"
###                 mw_project_set project_board "em.avnet.com:mini_module_plus_7z045_rev_c:part0:1.0"
###             }
###             default {
###                 mw_error "Board not found: $boardName_in"
###             }
###         }
###     }
###     puts [format "==> Using Board %s" [mw_project_get boardName]]
### }
### proc mw_add_board_repo {repoPath} {
###     set repoPath [file normalize $repoPath]
###     set repoPaths [get_param board.repoPaths]
###     lappend repoPaths $repoPath
###     set repoPaths [lsort -unique $repoPaths]
###     set_param board.repoPaths $repoPaths
### }
### proc mw_init_project {project_name} {
###     global commonDir
###     
###     # Setup the build directory
###     set buildDir [file normalize ./build]
###     file delete -force -- $buildDir
###     file mkdir $buildDir
###     mw_project_set buildDir $buildDir
### 
###     # Add the board directory to the repo paths
###     mw_add_board_repo ${commonDir}/boards
### 
###     mw_project_set boardDir ${commonDir}/boards/[mw_project_get boardName]
### 
###     if { [mw_project_get project_part] == "" } {
###         if { [mw_project_get project_board] ne "" } {
###             # Set the part based on the board
###             mw_project_set project_part [get_property PART_NAME [get_board_parts [mw_project_get project_board]]]
###         } else {
###             mw_error "project_part or project_board must be defined"
###         }
###     }
### 
###     create_project $project_name $buildDir -part [mw_project_get project_part] -force
###     file mkdir [mw_get_output_dir]
### 
###      if {[mw_project_get project_board] ne ""} {
###         set_property board_part [mw_project_get project_board] [current_project]
###     }
### 
###     if { [info procs board_init_project] == "board_init_project" } {
###         board_init_project
###     }
### }
### proc mw_load_board_tcl {boardName_in} {
###     global commonDir
### 
###     set board_tcl $commonDir/boards/$boardName_in/tcl/board_project.tcl
###     if { [file exists $board_tcl] } {
###         source $board_tcl
###     }
### }
### proc mw_setup_libs {} {
###     global mw_hdl_dir
### 
###     # cleanup local lib
###     set local_lib [mw_get_proj_dir]/lib
###     file delete -force $local_lib
###     file mkdir $local_lib
### 
###     mw_add_libdir $local_lib
###     mw_add_libdir $mw_hdl_dir/library
###     
### }
### proc mw_add_libdir { libdir } {
###     set proj_libs [get_property ip_repo_paths [current_fileset]]
###     lappend proj_libs $libdir
###     set proj_libs [lsort -unique $proj_libs]
###     set_property ip_repo_paths $proj_libs [current_fileset]
###     update_ip_catalog
### }
### proc mw_create_wrapper { {makeTop true} } {
###     if {[mw_get_build_target "wrapper"]} {
###         set BDFILEPATH [get_files -quiet system.bd]
###         make_wrapper -files $BDFILEPATH -top
###         # Try adding Block design filepath to naviagate & generate top wrapper
###         regsub -all "system.bd" [get_files -quiet system.bd] "hdl" TOPFILEPATH
###         catch {
###             add_files -norecurse $TOPFILEPATH
###             update_compile_order -fileset sources_1
###             }
###         if { $makeTop } {
###             set_property top system_wrapper [current_fileset]
###         }
###     }
### }
### proc mw_build_all {} {
###     mw_create_wrapper
###     mw_project_run
### }
### proc mw_project_run {} {
###     if {[mw_get_build_target "bdgen"]} {
###         mw_bd_generate
###     }
###     if {[mw_get_build_target "handoff"]} {
###         mw_gen_ps_init
###     }
###     if {[mw_get_build_target "fsbl"]} {
###         mw_create_fsbl
###     }
###     if {[mw_get_build_target "bitstream"]} {
###         mw_build_bit
###     }
### }
### proc mw_bd_generate {} {
###     set BDFILEPATH [get_files -quiet system.bd]
###     generate_target all $BDFILEPATH
### }
### proc mw_build_bit {} {
### 
###     set curdir [pwd]
###     cd [mw_get_proj_dir]
###     set project_name [get_property name [current_project]]
###     set top [get_property top [current_fileset]]
###     set bit_file ./${project_name}.runs/impl_1/${top}.bit
### 
###     launch_runs synth_1
###     wait_on_run synth_1
###     open_run synth_1
###     report_timing_summary -file timing_synth.log
### 
###     launch_runs impl_1 -to_step write_bitstream
###     wait_on_run impl_1
###     open_run impl_1
###     report_timing_summary -file timing_impl.log
### 
###     if [expr [get_property SLACK [get_timing_paths -delay_type min_max]] < 0] {
###         mw_error "Timing Constraints NOT met."
###     } else {
###         puts "-----------------------------------------------"
###         puts "SUCCESS: Bitstream generation complete."
###         puts "-----------------------------------------------"    
###     }
### 
###     file copy -force $bit_file [mw_get_output_dir]/system.bit
###     cd $curdir
### }
### proc mw_create_hdf {} {
###     set project_dir [mw_get_proj_dir]
###     set project_name [get_property name [current_project]]
###     set workspace ${project_dir}/${project_name}.sdk/
###     set hwdef $workspace/system.hdf
### 
###     file delete -force -- $workspace
###     file mkdir $workspace
### 
###     write_hwdef  -file $hwdef
### 
###     return $hwdef
### }
### proc mw_gen_ps_init {} {
###     set curdir [pwd]
###     set handoff_dir [mw_get_output_dir]/handoff
### 
###     file delete -force -- $handoff_dir
###     file mkdir $handoff_dir
### 
###     set hdfpath [mw_create_hdf]
###     set workspace [file dirname $hdfpath]
###     set hdf [file tail $hdfpath]
### 
###     cd $workspace
### 
###     # Generate the ps init files
###     hsi::open_hw_design $hdf
###     hsi::close_hw_design [hsi::current_hw_design]
### 
###     cd $curdir
### 
###     # Copy to the handoff dir
###     file copy {*}[glob ${workspace}/*gpl*] $handoff_dir/
### }
### proc mw_create_fsbl {} {
### 
###     global commonDir  
### 
###     set hdfpath [mw_create_hdf]
###     set workspace [file dirname $hdfpath]
###     set hdf [file tail $hdfpath]
### 
###     set elf_file $workspace/fsbl/executable.elf
###     set XSDK_PATH $::env(XILINX_SDK)
###     
###     set curdir [pwd]
###     
###     cd $workspace
###     hsi::open_hw_design $hdf
###     hsi::set_repo_path ${XSDK_PATH}/data/embeddedsw
###     [mw_project_get xsdk_proc]
###     
###     cd $curdir
###     
###     
###     foreach bin [mw_project_get xsdk_binaries] {
###         set binFile ${workspace}/${bin}
###         set outFile [string map {/ _} $bin]
###         file copy -force $binFile [mw_get_output_dir]/${outFile}
###     }
### }
### proc mw_create_zynq_fsbl {} {
###     set procs [hsi::get_cells -filter {IP_TYPE==PROCESSOR}] 
###     hsi::generate_app -hw [hsi::current_hw_design] -proc [lindex $procs 0] -app zynq_fsbl -os standalone -sw fsbl -dir fsbl -compile
### }
### proc mw_create_zynqmp_fsbl {} {
###     set procs [hsi::get_cells -filter {IP_TYPE==PROCESSOR && NAME =~ "*a53*"}] 
###     hsi::generate_app -hw [hsi::current_hw_design] -proc [lindex $procs 0] -app zynqmp_fsbl -os standalone -sw fsbl -dir fsbl -compile
###     hsi::generate_app -hw [hsi::current_hw_design] -proc psu_pmu_0 -app zynqmp_pmufw -os standalone -sw pmufw -dir pmufw -compile
###     exec mb-objcopy -O binary pmufw/executable.elf pmufw/executable.bin
### }
### proc mw_env_path_var {varname envname} {
###     global $varname
###  
###     if { ! [info exist $varname] } {
###         if  { [info exists ::env($envname)] } {
###             set $varname $::env($envname)
###         } else {
###             mw_error "Neither tcl variable $varname or environment variable $envname are set"
###         }   
###     }
###     set $varname [file normalize [set $varname]]
### }
### proc mw_get_proj_dir {} {
###     return [get_property DIRECTORY [current_project]]
### }
### proc mw_get_output_dir {} {
###     return [mw_get_proj_dir]/output
### }
### proc mw_error { msg } {
###     puts "-----------------------------------------------"
###     puts "ERROR: ${msg}"
###     puts "-----------------------------------------------"
###     error_on_bad_command
### }
### global mw_hdl_dir
### global commonDir
### set commonDir [file normalize [file dirname [file dirname [file dirname [info script]]]]]
### set mw_hdl_dir [file normalize [file dirname $commonDir]]
### source $commonDir/scripts/xilinx/mw_project_config.tcl
#### package require cmdline
#### proc mw_parse_cmdline {} {
####     global mw_project_params
####     global mw_project_usage
####     global mw_project_options
#### 
####     if { [info exists mw_project_options] } {
####         return
####     }
#### 
####     set mw_targets [list "bitstream" "fsbl" "wrapper" "bd"]
####     set mw_targets_help_str [join [list "Choose the build target:" [join $mw_targets ","]]]
#### 
####     set tvar_help_str "Set tcl vars in the format VARNAME1:VALUE1 VARNAME2:VALUE2 ..."
####     
####     set mw_project_params [list \
####         [list "target.arg" "bitstream" $mw_targets_help_str] \
####         [list "tvar.arg" "" $tvar_help_str] \
####     ]
#### 
####     set mw_project_usage "MathWorks Vivado Build Options"
####     if {[catch {array set options [cmdline::getoptions ::argv $mw_project_params $mw_project_usage]}]} {
####         puts [cmdline::usage $mw_project_params $mw_project_usage]
####         exit 0
####     } 
####     
####     set mw_project_options [array get options]
####     mw_check_cmdline_arg "target" $mw_targets
####     mw_set_tcl_vars
#### }
#### proc mw_set_tcl_vars {} {
####     set varlist [split [mw_get_opt tvar] " "]
####     foreach var $varlist {
####         set avpair [split $var ":"]
####         set name [lindex $avpair 0]
####         set val [lindex $avpair 1]
####         global $name
####         set $name $val
####     }
#### }
#### proc mw_check_cmdline_arg {argname {legal_vals [list]}} {
####     global mw_project_params
####     global mw_project_usage
#### 
####     set arg_val [mw_get_opt $argname]
#### 
####     if {[llength $legal_vals] != 0} {
####         if {[lsearch -exact $legal_vals $arg_val] == -1 } {
####             puts "Error: Invalid setting for '$argname': $arg_val"
####             puts [cmdline::usage $mw_project_params $mw_project_usage]
####             exit -1
####         }
####     }
####     return $arg_val
#### }
#### proc mw_get_opt {option} {
####     global mw_project_options
####     return [dict get $mw_project_options $option]
#### }
#### proc mw_set_build_target {tgt mode} {
####     if { $mode } {
####         mw_project_set "build_target_${tgt}" 1
####     } else {
####         mw_project_set "build_target_${tgt}" 0
####     }
#### }
#### proc mw_get_build_target {tgt} {
####     return [mw_project_get "build_target_${tgt}"]
#### }
#### proc mw_init_build_target {} {
####     global mw_project_build_target
#### 
####     mw_set_build_target "bitstream" 0
####     mw_set_build_target "fsbl" 0
####     mw_set_build_target "wrapper" 0
####     mw_set_build_target "bdgen" 0
####     mw_set_build_target "handoff" 0
#### }
#### proc mw_config_build_target {} {
####     if  { [mw_get_build_target "bitstream"] == "" } {
####         mw_init_build_target
#### 
####         set tgt [mw_get_opt "target"]
####         switch $tgt {
####             "bitstream" {
####                 mw_set_build_target "bitstream" 1
####                 mw_set_build_target "fsbl" 0
####                 mw_set_build_target "handoff" 1
####                 mw_set_build_target "wrapper" 1
####                 mw_set_build_target "bdgen" 1
####             }    
####             "fsbl" {
####                 mw_set_build_target "bitstream" 0
####                 mw_set_build_target "fsbl" 0
####                 mw_set_build_target "handoff" 1
####                 mw_set_build_target "wrapper" 1
####                 mw_set_build_target "bdgen" 1
####             }    
####             "wrapper" {
####                 mw_set_build_target "bitstream" 0
####                 mw_set_build_target "fsbl" 0
####                 mw_set_build_target "handoff" 0
####                 mw_set_build_target "wrapper" 1
####                 mw_set_build_target "bdgen" 1
####             }
####             "bd" {
####                 mw_set_build_target "bitstream" 0
####                 mw_set_build_target "fsbl" 0
####                 mw_set_build_target "handoff" 0
####                 mw_set_build_target "wrapper" 0
####                 mw_set_build_target "bdgen" 0
####             }        
####         }
####     }
#### }
#### mw_parse_cmdline
#### mw_config_build_target
### source $commonDir/scripts/xilinx/mw_bd.tcl
#### source $commonDir/scripts/xilinx/mw_bd_zynq.tcl
##### proc mw_default_bd_zynq { {core_freq 50.0} } {
#####     set curdir [pwd]
#####     cd [mw_get_proj_dir]
##### 
#####     # create board design
#####     create_bd_design "system"
##### 
#####     # GND and VCC nets    
#####     set const_vcc_inst [mw_create_const vcc 1 1]
##### 
#####     set const_gnd_inst [mw_create_const gnd 1 0]
##### 
#####     # Create the CPU interconnect
#####     set axi_cpu_interconnect [create_bd_cell -type ip -vlnv xilinx.com:ip:axi_interconnect:* axi_cpu_interconnect]
#####     set_property -dict [list CONFIG.NUM_MI {1}] $axi_cpu_interconnect
#####     set_property -dict [list CONFIG.S00_HAS_REGSLICE {4}] $axi_cpu_interconnect
#####     mw_project_set axi_cpu_interconnect $axi_cpu_interconnect
#####     
#####     # instance: sys_cpu
#####     mw_zynq_add_cpu
##### 
#####     set core_clkwiz [mw_create_clockwiz core sys_100m_clk proc_100m_resetn $core_freq]
##### 
#####     set sys_core_clk_source [get_bd_pins core_clkwiz/clk_out1]
#####     connect_bd_net -net sys_core_clk $sys_core_clk_source
#####     mw_project_set ipcore_clk_net [get_bd_nets sys_core_clk]
##### 
#####     set sys_core_rstgen [mw_rstsync sys_core sys_core_clk proc_100m_resetn core_clkwiz/locked]
#####     set sys_100m_rstgen [mw_rstsync sys_100m sys_100m_clk proc_100m_resetn]
#####     set sys_200m_rstgen [mw_rstsync sys_200m sys_200m_clk proc_200m_resetn]
#####     mw_project_set ipcore_rstn_net [get_bd_nets sys_core_resetn]
#####     mw_project_set ipcore_rst_net [get_bd_nets sys_core_reset]
#####     
#####     # interface connections
#####     connect_bd_net -net /sys_100m_clk [get_bd_pins axi_cpu_interconnect/ACLK]
#####     connect_bd_net -net /sys_100m_resetn [get_bd_pins axi_cpu_interconnect/ARESETN]
##### 
#####     connect_bd_net -net /sys_100m_clk [get_bd_pins axi_cpu_interconnect/S00_ACLK]
#####     connect_bd_net -net /sys_100m_resetn [get_bd_pins axi_cpu_interconnect/S00_ARESETN]
##### 
#####     connect_bd_net -net /sys_core_clk [get_bd_pins axi_cpu_interconnect/M00_ACLK]
#####     connect_bd_net -net /sys_core_resetn [get_bd_pins axi_cpu_interconnect/M00_ARESETN]
##### 
#####     
#####     cd $curdir
##### }
##### proc mw_zynq_add_cpu {} {
#####     switch [mw_project_get cpu_type] {
#####         zynqmp_arm {
#####             mw_zynqmp_add_ps
#####         }
#####         zynq7_arm {
#####             mw_zynq_add_ps7
#####         }
#####     }
##### }
##### proc mw_zynqmp_add_ps {} {
#####     
#####     set sys_cpu  [create_bd_cell -type ip -vlnv xilinx.com:ip:zynq_ultra_ps_e:* sys_cpu]
#####     apply_bd_automation -rule xilinx.com:bd_rule:zynq_ultra_ps_e -config {apply_board_preset "1"} $sys_cpu    
#####     set_property CONFIG.PSU__CRL_APB__PL0_REF_CTRL__FREQMHZ {100} $sys_cpu
#####     set_property CONFIG.PSU__USE__IRQ0 {1} $sys_cpu
#####     set_property CONFIG.PSU__USE__M_AXI_GP0 {1} $sys_cpu
#####     set_property CONFIG.PSU__USE__M_AXI_GP1 {0} $sys_cpu
#####     mw_project_set sys_cpu $sys_cpu
#####     
#####     # interrupt concat
#####     set intr_concat [create_bd_cell -type ip -vlnv xilinx.com:ip:xlconcat:* intr_concat]
#####     set_property -dict [list CONFIG.NUM_PORTS {8}] $intr_concat
#####     mw_create_const "intr_concat_gnd" 1 0
#####     for {set i 0} {$i < 8} {incr i} {
#####         connect_bd_net -net const_intr_concat_gnd [get_bd_pins intr_concat/In${i}]
#####     }
#####     connect_bd_net [get_bd_pins intr_concat/dout] [get_bd_pins sys_cpu/pl_ps_irq0]
#####     
#####     # system reset/clock definitions
#####     connect_bd_net -net sys_100m_clk [get_bd_pins sys_cpu/pl_clk0]
#####     connect_bd_net -net proc_100m_resetn [get_bd_pins sys_cpu/pl_resetn0]
#####     
#####     
#####     set proc_clkwiz [mw_create_clockwiz proc sys_100m_clk proc_100m_resetn 200]
#####     connect_bd_net -net sys_200m_clk [get_bd_pins proc_clkwiz/clk_out1]
#####     mw_rstsync proc_200m sys_200m_clk proc_100m_resetn proc_clkwiz/locked
#####     
#####     # Clocks and interconnects
#####     connect_bd_net -net /sys_100m_clk [get_bd_pins sys_cpu/maxihpm0_fpd_aclk]
#####     connect_bd_intf_net -intf_net axi_cpu_interconnect_s00_axi [get_bd_intf_pins axi_cpu_interconnect/S00_AXI] [get_bd_intf_pins sys_cpu/M_AXI_HPM0_FPD]
#####     
#####     mw_project_set sys_addr_cntrl_space [get_bd_addr_spaces sys_cpu/Data]
#####     
##### }
##### proc mw_zynq_add_ps7 {} {
#####     
#####     set sys_cpu  [create_bd_cell -type ip -vlnv xilinx.com:ip:processing_system7:* sys_cpu]
#####     apply_bd_automation -rule xilinx.com:bd_rule:processing_system7 -config {make_external "FIXED_IO, DDR" apply_board_preset "1"} $sys_cpu
#####     mw_project_set sys_cpu $sys_cpu
#####     
#####     set_property -dict [list CONFIG.PCW_USE_M_AXI_GP0 {1}] $sys_cpu
#####     set_property -dict [list CONFIG.PCW_EN_CLK1_PORT {1}] $sys_cpu
#####     set_property -dict [list CONFIG.PCW_EN_RST1_PORT {1}] $sys_cpu
#####     set_property -dict [list CONFIG.PCW_FPGA0_PERIPHERAL_FREQMHZ {100.0}] $sys_cpu
#####     set_property -dict [list CONFIG.PCW_FPGA1_PERIPHERAL_FREQMHZ {200.0}] $sys_cpu
#####     set_property -dict [list CONFIG.PCW_USE_FABRIC_INTERRUPT {1}] $sys_cpu
#####     set_property -dict [list CONFIG.PCW_IRQ_F2P_INTR {1}] $sys_cpu
#####     set_property -dict [list CONFIG.PCW_GPIO_EMIO_GPIO_ENABLE {1}] $sys_cpu
#####     set_property -dict [list CONFIG.PCW_GPIO_EMIO_GPIO_IO {32}] $sys_cpu
#####     set_property -dict [list CONFIG.PCW_TTC0_PERIPHERAL_ENABLE {0}] $sys_cpu
##### 
#####     # interrupt concat
#####     set intr_concat [create_bd_cell -type ip -vlnv xilinx.com:ip:xlconcat:* intr_concat]
#####     set_property -dict [list CONFIG.NUM_PORTS {16}] $intr_concat
#####     mw_create_const "intr_concat_gnd" 1 0
#####     for {set i 0} {$i < 16} {incr i} {
#####         connect_bd_net -net const_intr_concat_gnd [get_bd_pins intr_concat/In${i}]
#####     }
#####     connect_bd_net [get_bd_pins intr_concat/dout] [get_bd_pins sys_cpu/IRQ_F2P]
##### 
#####     # system reset/clock definitions
#####     connect_bd_net -net sys_100m_clk [get_bd_pins sys_cpu/FCLK_CLK0]
#####     connect_bd_net -net sys_200m_clk [get_bd_pins sys_cpu/FCLK_CLK1]
#####     connect_bd_net -net proc_100m_resetn [get_bd_pins sys_cpu/FCLK_RESET0_N]
#####     connect_bd_net -net proc_200m_resetn [get_bd_pins sys_cpu/FCLK_RESET1_N]
#####     
#####     # Clocks and interconnects
#####     connect_bd_net -net /sys_100m_clk [get_bd_pins sys_cpu/M_AXI_GP0_ACLK]
#####     connect_bd_intf_net -intf_net axi_cpu_interconnect_s00_axi [get_bd_intf_pins axi_cpu_interconnect/S00_AXI] [get_bd_intf_pins sys_cpu/M_AXI_GP0]
#####     
#####     mw_project_set sys_addr_cntrl_space [get_bd_addr_spaces sys_cpu/Data]
##### }
##### proc mw_add_cpu_axi_slave {{port 0} {ic_name {}} {clk sys_core_clk} {rstn sys_core_resetn}} {
#####     set cpu_type [mw_project_get cpu_type]
#####     set cpu_name [get_property "name" [mw_get_cpu]]
#####     switch $cpu_type {
#####         zynqmp_arm {
#####             set gpport [expr {$port + 2}]
#####             set_property -dict [list CONFIG.PSU__USE__S_AXI_GP${gpport} {1}] [mw_get_cpu]
#####             set slave_clk_pin [get_bd_pins ${cpu_name}/saxihp${port}_fpd_aclk]
#####             set slave_intf_pin [get_bd_intf_pins ${cpu_name}/S_AXI_HP${port}_FPD]
#####             set slave_seg [get_bd_addr_segs ${cpu_name}/SAXIGP${gpport}/HP${port}_DDR_LOW]
#####         }
#####         zynq7_arm {
#####             set_property -dict [list CONFIG.PCW_USE_S_AXI_HP${port} {1}] [mw_get_cpu]
#####             set slave_clk_pin [get_bd_pins ${cpu_name}/S_AXI_HP${port}_ACLK]
#####             set slave_intf_pin [get_bd_intf_pins ${cpu_name}/S_AXI_HP${port}]
#####             set slave_seg [get_bd_addr_segs ${cpu_name}/S_AXI_HP${port}/HP${port}_DDR_LOWOCM]
#####         }
#####         default {
#####             mw_error "Unsupported CPU type: $cpu_type"
#####         }
#####     }
#####     
#####     mw_connect_pin $clk $slave_clk_pin
##### 
#####     if { [llength $ic_name] == 0 } {
#####         set ic_name axi_cpu_slave_ic_${port}
#####     }
##### 
#####     set ic [create_bd_cell -type ip -vlnv xilinx.com:ip:axi_interconnect:* $ic_name]
#####     set_property -dict [list CONFIG.NUM_MI {1}] $ic
#####     set_property -dict [list CONFIG.S00_HAS_REGSLICE {4}] $ic
#####     set_property -dict [list CONFIG.M00_HAS_REGSLICE {4}] $ic
##### 
#####     mw_connect_pin ${clk} ${ic_name}/ACLK
#####     mw_connect_pin ${rstn} ${ic_name}/ARESETN
#####     
#####     mw_connect_pin ${clk} ${ic_name}/M00_ACLK
#####     mw_connect_pin ${rstn} ${ic_name}/M00_ARESETN
#####     mw_connect_pin ${ic_name}/M00_AXI $slave_intf_pin
#####     
#####     return [list $ic $slave_seg ]
##### }
#### source $commonDir/scripts/xilinx/mw_bd_fpga.tcl
##### proc mw_default_bd_pcie { {core_freq 50.0} } {
#####     set curdir [pwd]
#####     cd [mw_get_proj_dir]
#####     # create board design
#####     create_bd_design "system"
##### 
#####     global sys_pcie
##### 
#####     global pcie_int_input
#####     global pcie_core
#####     global pcie_perst_n
#####     global pcie_axi_clk
#####     global pcie_m_axi
#####     global pcie_s_axi
#####     global pcie_s_axi_ctl
##### 
#####     global commonDir
##### 	
##### 	global BOARD_DEBUG
#####     
#####     
#####     # Add the pcie contraints (if they exist)
#####     set pcie_constr [mw_project_get boardDir]/xdc/pcie.xdc
#####     if { [file exists $pcie_constr] } {
#####         add_files -norecurse -fileset sources_1 $pcie_constr
#####     }
#####     
#####     # load the board data
#####     source [mw_project_get boardDir]/tcl/board_bd.tcl
##### 
#####     # GND and VCC nets
#####     set const_vcc_inst [create_bd_cell -type ip -vlnv xilinx.com:ip:xlconstant:* const_vcc_inst]
#####     connect_bd_net -net const_vcc [get_bd_pins const_vcc_inst/dout] 
##### 
#####     set const_gnd_inst [create_bd_cell -type ip -vlnv xilinx.com:ip:xlconstant:* const_gnd_inst]
#####     set_property -dict [list CONFIG.CONST_VAL {0}] $const_gnd_inst
#####     connect_bd_net -net const_gnd [get_bd_pins const_gnd_inst/dout] 
##### 
#####     # Create PCIe core
##### 
#####     set sys_pcie [board_setup_pcie]
#####     
#####     mw_project_set sys_cpu $sys_pcie
#####     
#####     # Create the fixed 100/200 MHz clocks
#####     set sys_clkwiz [mw_create_clockwiz sys $pcie_axi_clk pcie_axi_resetn 100.0]
#####     set_property -dict [list CONFIG.CLKOUT2_USED {true}] $sys_clkwiz
#####     set_property -dict [list CONFIG.CLKOUT2_REQUESTED_OUT_FREQ {200.0}] $sys_clkwiz
#####     connect_bd_net -net sys_100m_clk [get_bd_pins sys_clkwiz/clk_out1]
#####     connect_bd_net -net sys_200m_clk [get_bd_pins sys_clkwiz/clk_out2]
##### 
#####     set sys_100m_rstgen [mw_rstsync sys_100m sys_100m_clk $pcie_perst_n sys_clkwiz/locked]
#####     set sys_200m_rstgen [mw_rstsync sys_200m sys_200m_clk $pcie_perst_n sys_clkwiz/locked]
##### 
##### 
#####     # Create the core clock
#####     set core_clkwiz [mw_create_clockwiz core $pcie_axi_clk pcie_axi_resetn $core_freq]
#####     set sys_core_clk_source [get_bd_pins core_clkwiz/clk_out1]
#####     connect_bd_net -net sys_core_clk $sys_core_clk_source
#####     mw_project_set ipcore_clk_net [get_bd_nets sys_core_clk]
##### 
#####     set sys_core_rstgen [mw_rstsync sys_core sys_core_clk $pcie_perst_n core_clkwiz/locked]
#####     mw_project_set ipcore_rstn_net [get_bd_nets sys_core_resetn]
#####     mw_project_set ipcore_rst_net [get_bd_nets sys_core_reset]
##### 
#####     # Create interrupt controller
#####     set axi_intc [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_intc:* axi_intc ]
#####     set_property -dict [ list CONFIG.C_IRQ_IS_LEVEL {0} ] $axi_intc
#####     set_property CONFIG.C_KIND_OF_EDGE.VALUE_SRC PROPAGATED $axi_intc
##### 	set_property CONFIG.C_KIND_OF_LVL.VALUE_SRC PROPAGATED $axi_intc
##### 	set_property CONFIG.C_KIND_OF_INTR.VALUE_SRC PROPAGATED $axi_intc
##### 	set_property CONFIG.C_IRQ_CONNECTION 1 $axi_intc
##### 	connect_bd_net -net $pcie_int_input [get_bd_pins axi_intc/irq]
#####     connect_bd_net -net $pcie_axi_clk [get_bd_pins axi_intc/s_axi_aclk]
#####     connect_bd_net -net pcie_axi_resetn [get_bd_pins axi_intc/s_axi_aresetn]
##### 
#####     # interrupt concat
#####     set intr_concat [create_bd_cell -type ip -vlnv xilinx.com:ip:xlconcat:* intr_concat]
#####     set_property -dict [list CONFIG.NUM_PORTS {32}] $intr_concat
#####     mw_create_const "intr_concat_gnd" 1 0
#####     for {set i 0} {$i < 32} {incr i} {
#####         connect_bd_net -net const_intr_concat_gnd [get_bd_pins intr_concat/In${i}]
#####     }
#####     connect_bd_net -net intr_concat_dout [get_bd_pins axi_intc/intr] [get_bd_pins intr_concat/dout]
#####     mw_project_set intr_concat $intr_concat
#####     
#####     
#####     # Create the CPU Interconnect
#####     set axi_cpu_interconnect [create_bd_cell -type ip -vlnv xilinx.com:ip:axi_interconnect:* axi_cpu_interconnect]
#####     set_property -dict [list CONFIG.NUM_MI {1}] $axi_cpu_interconnect
#####     set_property -dict [list CONFIG.S00_HAS_REGSLICE {4}] $axi_cpu_interconnect
#####     mw_project_set axi_cpu_interconnect $axi_cpu_interconnect
##### 
##### 
#####     # interface connections  
#####     board_connect
##### 
#####     connect_bd_net -net /sys_core_clk [get_bd_pins axi_cpu_interconnect/M00_ACLK]
#####     connect_bd_net -net /sys_core_resetn [get_bd_pins axi_cpu_interconnect/M00_ARESETN]
##### 
#####     mw_add_cpu_slave axi_intc 0x1000000
##### 
##### 	if { [info exists BOARD_DEBUG] && $BOARD_DEBUG } {
##### 		board_enable_debug
##### 	}
##### 	
#####     cd $curdir
##### }
##### proc mw_get_pcie_slave_ic {} {
#####     global pcie_s_axi
#####     global pcie_axi_clk
##### 
#####     set ic_name pcie_axi_slave_interconnect
#####     set ic [get_bd_cells -quiet $ic_name]
#####     if { [llength $ic] > 0 } {
#####         return $ic
#####     }
##### 
#####     set ic [create_bd_cell -type ip -vlnv xilinx.com:ip:axi_interconnect:* $ic_name]
#####     set_property -dict [list CONFIG.NUM_MI {1}] $ic
#####     set_property -dict [list CONFIG.S00_HAS_REGSLICE {4}] $ic
#####     set_property -dict [list CONFIG.M00_HAS_REGSLICE {4}] $ic
##### 
#####     connect_bd_net -net $pcie_axi_clk [get_bd_pins ${ic_name}/ACLK] 
#####     connect_bd_net -net pcie_axi_interconnect_resetn [get_bd_pins ${ic_name}/ARESETN] 
##### 
#####     connect_bd_net -net $pcie_axi_clk [get_bd_pins ${ic_name}/M00_ACLK] 
#####     connect_bd_net -net pcie_axi_resetn [get_bd_pins ${ic_name}/M00_ARESETN]
##### 
#####     connect_bd_intf_net [get_bd_intf_pins ${ic_name}/M00_AXI] $pcie_s_axi
#####     
#####     return $ic
##### }
##### proc mw_get_pcie_axi_slave_ports { {num_ports 1} {clk_domain pcie_axi} } {
##### 
#####     set ic [mw_get_pcie_slave_ic]
#####     set ic_name [get_property NAME $ic]
#####     
#####     set ports []
#####     set found_ports 0
#####     set MAX_MASTER_PORTS 16
#####     
#####     for {set idx 0} {$idx < $MAX_MASTER_PORTS} {incr idx} {
#####         set SI_IDX [format %02d $idx]
#####         set NUM_SI [get_property CONFIG.NUM_SI $ic]
#####         set if_pin [get_bd_intf_pins -quiet ${ic_name}/S${SI_IDX}_AXI]
#####         if { [llength [get_bd_intf_nets -quiet -of_objects $if_pin]] == 0 } {
#####             lappend ports $if_pin
#####             incr found_ports
#####             mw_connect_pin [get_bd_pins ${ic_name}/S${SI_IDX}_ACLK] ${clk_domain}_clk
#####             mw_connect_pin [get_bd_pins ${ic_name}/S${SI_IDX}_ARESETN] ${clk_domain}_resetn
#####         }
#####         if {$found_ports == $num_ports} {
#####             break
#####         }
#####         if { $NUM_SI == [expr $SI_IDX + 1] } {
#####             mw_add_ic_slave_port $ic
#####         }
#####     }
#####     
#####     if { $found_ports != $num_ports } {
#####         mw_error "Could not find $num_ports slave ports"
#####     }
#####     return $ports
#####     
#####     return $ports
##### }
#### proc mw_default_bd { {core_freq 50.0} } {
####     switch [mw_project_get cpu_type] {
####         zynqmp_arm -
####         zynq7_arm {
####             mw_default_bd_zynq $core_freq
####         }
####         kintex7_pcie {
####             mw_default_bd_pcie $core_freq
####         }
####     }
#### }
#### proc mw_create_clockwiz { name srcclk srcrst clk_freq } {
####     set clkwiz_name "${name}_clkwiz"
####     set clkwiz [create_bd_cell -type ip -vlnv xilinx.com:ip:clk_wiz:* $clkwiz_name]
####     set_property -dict [list CONFIG.PRIM_SOURCE {Global_buffer}] $clkwiz
####     set_property -dict [list CONFIG.RESET_TYPE {ACTIVE_LOW}] $clkwiz
####     set_property -dict [list CONFIG.CLKOUT1_REQUESTED_OUT_FREQ $clk_freq] $clkwiz
####     connect_bd_net -net [mw_getnet $srcclk] [get_bd_pins $clkwiz_name/clk_in1]
####     connect_bd_net -net [mw_getnet $srcrst] [get_bd_pins $clkwiz_name/resetn]
#### 
####     return $clkwiz
#### 
#### }
#### proc mw_create_dummy_slave { {ic_port 0} } {
#### 
####     set dummy_name axi_gpio_dummy_0
####     set dummy_obj [create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:* $dummy_name]
####     set_property -dict [list CONFIG.C_GPIO_WIDTH {1} CONFIG.C_ALL_OUTPUTS {1}] $dummy_obj
####     set_property -dict [list CONFIG.C_GPIO2_WIDTH {1} CONFIG.C_IS_DUAL {1} CONFIG.C_ALL_INPUTS_2 {1}] $dummy_obj
#### 
####     mw_connect_pin [mw_project_get ipcore_clk_net] $dummy_name/s_axi_aclk
####     mw_connect_pin [mw_project_get ipcore_rstn_net] $dummy_name/s_axi_aresetn
####     mw_connect_pin $dummy_name/gpio_io_o $dummy_name/gpio2_io_i
####     
####     mw_add_cpu_slave $dummy_name [mw_project_get mw_ip_baseaddr] $ic_port
####     
####     return $dummy_obj
#### }
#### proc mw_add_axi_dma {name {rd_en 1} {wr_en 1}} {
####     set axi_dma [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_dma:* $name ]
####     set_property -dict [ list CONFIG.c_sg_include_stscntrl_strm {0}  ] $axi_dma
#### 
####     if {!$rd_en} {
####         set_property -dict [list CONFIG.c_include_mm2s {0}] $axi_dma
####     }
#### 
####     if {!$wr_en} {
####         set_property -dict [list CONFIG.c_include_s2mm {0}] $axi_dma
####     }
#### 
####     return $axi_dma
#### }
#### proc mw_get_sys_addr_cntrl_space {} {
####     set addr_space [mw_project_get sys_addr_cntrl_space]
####     
####     if { [llength $addr_space] == 0 } {
####         set sys_cpu [mw_get_cpu]
####         set addr_space [get_bd_addr_spaces -of_objects $sys_cpu]
####     }
####     
####     if { [llength $addr_space] == 0 } {
####         set addr_space [get_bd_addr_spaces -filter "PATH =~ [mw_get_cpu]/Data"]
####     }
####     
####     return $addr_space
#### }
#### proc mw_bd_export {filename} {
####     save_bd_design
####     #validate block design is commented since vivado 2017.4 error out unconnected AXI Master interface g1732687 
####     #validate_bd_design
#### 
####     write_bd_tcl [mw_get_output_dir]/$filename
#### }
#### proc mw_add_ic_slave_port { ic } {
####     set ic_name [get_property NAME $ic]
####     
####     set NUM_SI [get_property CONFIG.NUM_SI $ic]
####     set NUM_SI [expr $NUM_SI + 1]
####     set SI_IDX [format %02d [expr $NUM_SI -1]]
####     set_property -dict [list CONFIG.NUM_SI $NUM_SI] $ic
####     set_property -dict [list CONFIG.S${SI_IDX}_HAS_REGSLICE {4}] $ic
#### }
#### proc mw_add_interconnect_slave {ic_name bd_slave {ic_port "auto"} {regslice 4} {datafifo 0}} {
#### 
####     set ic_obj [get_bd_cells $ic_name]
####     set slave_info [mw_s_axi_info $bd_slave]
####     set dst_port [get_bd_intf_pins [lindex $slave_info 0]]
####     set clk_net [get_bd_nets -of_objects [lindex $slave_info 1]]
####     set rst_net [get_bd_nets -of_objects [lindex $slave_info 2]]
#### 
####     set NUM_MI [get_property CONFIG.NUM_MI $ic_obj]
####     if {$ic_port == "auto"} {
####         set ic_port $NUM_MI
####     }
####     if { $NUM_MI <= $ic_port } {
####         set NUM_MI [expr $ic_port + 1]
####         set_property -dict [list CONFIG.NUM_MI $NUM_MI] $ic_obj
####     }
####     set MI_IDX [format %02d $ic_port]
#### 
####     set_property -dict [list CONFIG.M${MI_IDX}_HAS_REGSLICE $regslice] $ic_obj
####     set_property -dict [list CONFIG.M${MI_IDX}_HAS_DATA_FIFO $datafifo] $ic_obj 
#### 
####     set m_clk_pin [get_bd_pins ${ic_name}/M${MI_IDX}_ACLK]
####     set m_rst_pin [get_bd_pins ${ic_name}/M${MI_IDX}_ARESETN]
#### 
####     mw_disconnect_pin ${ic_name}/M${MI_IDX}_AXI
####     mw_disconnect_pin $m_clk_pin
####     mw_disconnect_pin $m_rst_pin
####     connect_bd_net -net $clk_net $m_clk_pin
####     connect_bd_net -net $rst_net $m_rst_pin
####     
####     connect_bd_intf_net [get_bd_intf_pins ${ic_name}/M${MI_IDX}_AXI] $dst_port
#### 
#### }
#### proc mw_add_cpu_slave {bd_slave offset {ic_port "auto"} {regslice 4} {datafifo 0}} {
####     mw_add_interconnect_slave [mw_project_get axi_cpu_interconnect] $bd_slave $ic_port $regslice $datafifo 
####     
####     set slave_info [mw_s_axi_info $bd_slave]
####     set addr_seg [lindex $slave_info 3]
####     # Minimum range is 4k
####     set range [expr max([get_property RANGE $addr_seg],4096)]
####     create_bd_addr_seg -range $range -offset $offset [mw_get_sys_addr_cntrl_space]  $addr_seg  SEG_data_${bd_slave}
#### }
#### proc mw_s_axi_info {bd_cell_name} {
####     set bd_cell [get_bd_cells $bd_cell_name]
####     set s_axi [get_bd_intf_pins -filter \
####     "MODE == Slave  && VLNV == xilinx.com:interface:aximm_rtl:1.0" \
####     -of_objects $bd_cell]
####     set s_axi_pin [lrange [split $s_axi "/"] end end]
####     set s_axi_clk [get_bd_pins -filter "TYPE == clk && (CONFIG.ASSOCIATED_BUSIF == ${s_axi_pin} || \
####     CONFIG.ASSOCIATED_BUSIF =~ ${s_axi_pin}:* || CONFIG.ASSOCIATED_BUSIF =~ *:${s_axi_pin} || \
####     CONFIG.ASSOCIATED_BUSIF =~ *:${s_axi_pin}:*)" -quiet -of_objects $bd_cell]
####     set s_axi_clk [get_bd_pins [mw_list_reduce $s_axi_clk ".*${s_axi_pin}.*"]]
####     set s_axi_rst [get_bd_pins -filter "TYPE == rst && (CONFIG.ASSOCIATED_BUSIF == ${s_axi_pin} || \
####     CONFIG.ASSOCIATED_BUSIF =~ ${s_axi_pin}:* || CONFIG.ASSOCIATED_BUSIF =~ *:${s_axi_pin} || \
####     CONFIG.ASSOCIATED_BUSIF =~ *:${s_axi_pin}:*)" -quiet -of_objects $bd_cell]
####     if {($s_axi_clk ne "") && ($s_axi_rst eq "")} {
####         set s_axi_rst [get_property CONFIG.ASSOCIATED_RESET [get_bd_pins ${s_axi_clk}]]
####         if {$s_axi_rst ne ""} {
####             set s_axi_rst [get_bd_pins ${bd_cell_name}/$s_axi_rst]
####         }
####         if {$s_axi_rst eq ""} {
####             # Find a reset pin with the same root
####             set clkPin [lrange [split $s_axi_clk "/"] end end]
####             set clkRoot ""
####             regexp -all "(.*?)_?\[:alpha:\]*clk.*" $clkPin -> clkRoot
####             set s_axi_rst [get_bd_pins -of_objects $bd_cell -regexp -filter [subs -nobackslashes -nocommands {NAME =~ ".*${clkRoot}.*re?se?t.*"}]]
####         }
####     }
####     if {$s_axi_rst eq ""} {
####         # Find any reset pin
####         set s_axi_rst [get_bd_pins -of_objects $bd_cell -regexp -filter {NAME =~ ".*re?se?t.*"}]
####     }
####     set s_axi_rst [get_bd_pins [mw_list_reduce $s_axi_rst ".*${s_axi_pin}.*"]]
#### 
####     set s_addr_seg [get_bd_addr_segs -of_objects [get_bd_intf_pins $s_axi]]
#### 
####     return [list $s_axi $s_axi_clk $s_axi_rst $s_addr_seg]
#### }
#### proc mw_create_const {name width value} {
####     set const_name const_${name}
####     set const_block [create_bd_cell -type ip -vlnv xilinx.com:ip:xlconstant:* $const_name]
####     set_property -dict [list CONFIG.CONST_WIDTH $width] $const_block
####     set_property -dict [list CONFIG.CONST_VAL $value] $const_block
####     connect_bd_net -net $const_name [get_bd_pins ${const_name}/dout]
####     
####     return $const_block
#### }
#### proc mw_logic {name op in1 {out {}} {in2 {}} {size 1} } {
####     set lname logic_${op}_${name}
####     
####     set logic_cell [create_bd_cell -type ip -vlnv xilinx.com:ip:util_vector_logic:* $lname]
####     set_property -dict [list CONFIG.C_SIZE $size] $logic_cell
####     set_property -dict [list CONFIG.C_OPERATION $op] $logic_cell
####     connect_bd_net -net [mw_getnet $in1] [get_bd_pins $lname/Op1]
####     if { [llength $in2] > 0 } {
####         connect_bd_net -net [mw_getnet $in2] [get_bd_pins $lname/Op2]
####     }
####     if { [llength $out] > 0 } {
####         connect_bd_net -net [mw_getnet $out] [get_bd_pins $lname/Res]
####     } else {
####         connect_bd_net -net ${lname}_Res [get_bd_pins $lname/Res]
####     }
####     return [mw_getnet [get_bd_pins $lname/Res]]
#### }
#### proc mw_list_reduce {lst filter} {
####     if { [llength $lst] > 1 } {
####         set found_item [lsearch -inline -regexp $lst ${filter}]
####         if {[llength $found_item] > 0} {
####             set lst [lindex $found_item 0]
####         } else {
####             set lst [lindex $found_item 0]    
####         }
####     }
####     return $lst
#### }
#### proc mw_get_cpu {} {
####     set sys_cpu [mw_project_get sys_cpu]
####     if { [llength $sys_cpu] == 0 } {
####         set sys_cpu [get_bd_cells -hierarchical -filter {VLNV=~"xilinx.com:ip:processing_system7:*" || VLNV=~"xilinx.com:ip:zynq_ultra_ps_e:*"}]
####     }
####     return $sys_cpu
#### }
#### proc mw_get_intr_concat {{intr_num 0}} {
####     set intr_concat [mw_project_get intr_concat]
####     set cpu_type [mw_project_get cpu_type]
####     
####     if {[llength $intr_concat] == 0} {
####         # Find the INTC if needed
####         set cpu_name [get_property "name" [mw_get_cpu]]
####         switch $cpu_type {
####             zynqmp_arm {
####                 if { $intr_num < 8 } {
####                     set intr_ports ${cpu_name}/pl_ps_irq0
####                 } else {
####                     set intr_ports ${cpu_name}/pl_ps_irq1
####                 }
####             }
####             zynq7_arm {
####                 set intr_ports ${cpu_name}/IRQ_F2P
####             }
####             kintex7_pcie {
####                 set intr_ports 
####             }
####             default {
####                 mw_error "Unsupported CPU type: $cpu_type"
####             }
####         }
####         set irq_src [get_bd_pins -of_objects [mw_getnet $intr_ports] -filter {DIR == O}]
####         set intr_concat [get_bd_cells -of_objects $irq_src]
####     }
####     switch $cpu_type {
####         #Remap the interrupt number if needed
####         zynqmp_arm {
####             if { $intr_num >= 8 } {
####                 set intr_num [expr $intr_num - 8]
####             }
####         }
####     }
####     return [list $intr_concat $intr_num]
#### }
#### proc mw_connect_intr {src_pin intr_num} {
####     set intr_info [mw_get_intr_concat $intr_num]
####     set intr_concat [lindex $intr_info 0]
####     set intr_num [lindex $intr_info 1]
####     set intr_concat_name [get_property "name" $intr_concat]
####     
####     set intr_pin ${intr_concat_name}/In${intr_num}
####     mw_disconnect_pin $intr_pin
####     mw_connect_pin $src_pin $intr_pin
#### }
#### proc mw_rstsync {name sync_clk {ext_rst {} } {locked {} } } {
####     set rstgen_name ${name}_rstgen
####     set rstgen [create_bd_cell -type ip -vlnv xilinx.com:ip:proc_sys_reset:* $rstgen_name]
####     set_property -dict [list CONFIG.C_EXT_RST_WIDTH {1}] $rstgen
#### 
####     connect_bd_net -net [mw_getnet $sync_clk] [get_bd_pins ${rstgen_name}/slowest_sync_clk]
####     if { [llength $ext_rst] > 0 } {
####         connect_bd_net -net [mw_getnet $ext_rst] [get_bd_pins ${rstgen_name}/ext_reset_in]
####     }
####     if { [llength $locked] > 0 } {
####         connect_bd_net -net [mw_getnet $locked] [get_bd_pins ${rstgen_name}/dcm_locked]
####     }
#### 
####     connect_bd_net -net ${name}_resetn [get_bd_pins ${rstgen_name}/peripheral_aresetn]
####     connect_bd_net -net ${name}_interconnect_resetn [get_bd_pins ${rstgen_name}/interconnect_aresetn]
####     connect_bd_net -net ${name}_reset [get_bd_pins ${rstgen_name}/peripheral_reset]
#### 
####     return $rstgen
#### }
#### proc mw_getnet {pin_net {create_net true}} {
####     # check if its a pin or port
####     set pin [mw_get_pin_port $pin_net]
####     if { [llength $pin] == 0 } {
####         # check if its a net
####         set net [mw_get_net_from_name $pin_net]
####         if { [llength $net] == 0 } {
####             mw_error "Could not find pin/port/net: ${pin_net}"
####         } else {
####             return $net
####         }
####     }
####     # Found a pin or port, check if it's connected
####     set net [mw_get_net_of_pin $pin]    
####     # check if there's already a net attached
####     if { [llength $net] > 0 || ! $create_net} {
####         return $net
####     } else {
####         # create and attach a new net
####         
####         set netName [join [list [regsub {^[^[:alpha:]]} [regsub -all {/} $pin {_}] {}] "_net"] ""]
####         if { [mw_is_intf $pin] } {
####             set net [create_bd_intf_net ${netName}_intf]
####             connect_bd_intf_net -intf_net $net $pin
####         } else {
####             set net [create_bd_net $netName]
####             connect_bd_net -net $net $pin
####         }
####         return $net
####     }
#### }
#### proc mw_cleanup_orphans {{netlimit 1}} {
####     set cleaned 1
####     set iters 0
####     while {$cleaned > 0 && $iters < 5} {
####         set cleaned [mw_cleanup_orphan_cells]
####         incr cleaned [mw_cleanup_orphan_nets $netlimit]
####         incr iters
####     }
#### }
#### proc mw_cleanup_orphan_nets {{netlimit 1}} {
####     set netlimit [expr $netlimit + 1]
####     set allNets [get_bd_nets]
####     set cleaned 0
####     foreach net $allNets {
####         set pins [get_bd_pins -quiet -of_objects $net]
####         set ports [get_bd_ports -quiet -of_objects $net]
####         set numConnections [expr [llength $pins] + [llength $ports]]
####         if { $numConnections < $netlimit} {
####             puts "Deleting orphan net $net"
####             delete_bd_objs $net
####             incr cleaned
####         }
####     }
####     
####     set allNets [get_bd_intf_nets]
####     foreach net $allNets {
####         set pins [get_bd_intf_pins -quiet -of_objects $net]
####         set ports [get_bd_intf_ports -quiet -of_objects $net]
####         set numConnections [expr [llength $pins] + [llength $ports]]
####         if { $numConnections < $netlimit} {
####             puts "Deleting orphan net $net"
####             delete_bd_objs $net
####             incr cleaned
####         }
####     }
####     
####     return $cleaned
#### }
#### proc mw_cleanup_orphan_cells {} {
####     set allCells [get_bd_cells]
####     set cleaned 0
####     foreach cell $allCells {
####         if {[mw_cell_is_dangling $cell]} {
####             puts "Removing orphan cell $cell"
####             delete_bd_objs $cell
####             incr cleaned
####         }
####     }
####     return $cleaned
#### }
#### proc mw_cell_is_dangling {cell_name} {
####     set cell [get_bd_cells $cell_name]
####     set opins [get_bd_pins -of_objects $cell -filter {DIR == O} -quiet]
####     set onets [get_bd_nets -of_objects $opins -quiet]
####     set ipins [get_bd_pins -of_objects $onets -filter {DIR == I} -quiet]
####     
####     if {[llength $ipins] > 0} {
####         return false
####     }
####     
####     set ifpins [get_bd_intf_pins -of_objects $cell -quiet]
####     set ifnets [get_bd_intf_nets -of_objects $ifpins -quiet]
####     foreach ifn $ifnets {
####         set if_pins [get_bd_intf_pins -of_objects $ifn]
####         if {[llength $if_pins] > 1} {
####             return false
####         }
####     }
####     
####     return true
#### }
#### proc mw_is_intf {pin_net} {
####     set ipin [get_bd_intf_pins -quiet $pin_net]
####     set iports [get_bd_intf_ports -quiet $pin_net]
####     set inets [get_bd_intf_nets -quiet $pin_net]
####     set intf [expr [llength $ipin] + [llength $iports] + [llength $inets]]
####     if { $intf > 0 } {
####         return true 
####     } else {
####         return false
####     }
#### }
#### proc mw_get_net_of_pin {pin} {
####     set pin [mw_get_pin_port $pin]
####     set net [get_bd_nets -of_objects $pin -quiet]
####     if { [llength $net] == 0 } {
####         set net [get_bd_intf_nets -of_objects $pin -quiet]
####     }
####     return $net
#### }
#### proc mw_get_net_from_name {net_name} {    
####     set net [get_bd_nets -quiet $net_name]
####     if { [llength $net] == 0 } {
####         set net [get_bd_intf_nets -quiet $net_name]
####     }
####     return $net
#### }
#### proc mw_get_pin_port {pin_port} {
####     # check if its a port
####     set pin [get_bd_ports -quiet $pin_port]
####     if { [llength $pin] == 0 } {
####         # check if its a pin
####         set pin [get_bd_pins -quiet $pin_port]
####     }
####     
####     if { [llength $pin] == 0 } {
####         # check if its a intf pin
####         set pin [get_bd_intf_pins -quiet $pin_port]
####     }
####     
####     if { [llength $pin] == 0 } {
####         # check if its a intf port
####         set pin [get_bd_intf_ports -quiet $pin_port]
####     }
####     
####     return $pin
#### }
#### proc mw_is_input {pin_port} {
####     set pin [mw_get_pin_port $pin_port]
####     if { [llength $pin] == 0 } {
####         return 0
####     }
####     set dir [get_property DIR $pin]
####     if {$dir == "I"} {
####         return 1
####     } else {
####         return 0
####     }    
#### }
#### proc mw_is_net {pin_net} {
####     set net [mw_getnet $pin_net false]
####     if { [llength $net] > 0 } {
####         return true
####     } else {
####         return false
####     }
#### }
#### proc mw_connect_pin {pin_net1 pin_net2} {
####     
####     set isNet1 [mw_is_net $pin_net1]
####     set isNet2 [mw_is_net $pin_net2]
####     
####     if { $isNet1 && $isNet2 } {
####         mw_error "$pin_net1 and $pin_net2 both have existing nets"
####     }
####     
####     if { [mw_is_intf $pin_net1] } {
####         # Cannot have dangling nets on intf pins
####         connect_bd_intf_net [mw_get_pin_port $pin_net1] [mw_get_pin_port $pin_net2]
####         return
####     }
####     
####     if { ! ($isNet1 || $isNet2) } {
####         # No nets are attached, both are unconnected pins
####         if { [mw_is_input $pin_net1] } {
####             # Attach a net to the output pin
####             set netArg [mw_getnet $pin_net2]
####             # Connect to the input pin
####             set pinArg [mw_get_pin_port $pin_net1]
####         } else {
####             # Attach a net to the output pin
####             set netArg [mw_getnet $pin_net1]
####             # Connect to the input pin
####             set pinArg [mw_get_pin_port $pin_net2]
####         }
####     } elseif { $isNet1 } {
####         # Pin1 has a net attached
####         set netArg [mw_getnet $pin_net1]
####         # Connect to the other net
####         set pinArg [mw_get_pin_port $pin_net2]
####     } else {
####         # Pin2 has a net attached
####         set netArg [mw_getnet $pin_net2]
####         # Connect to the other net
####         set pinArg [mw_get_pin_port $pin_net1]
####     }
####     connect_bd_net -net $netArg $pinArg
#### }
#### proc mw_is_connected {pin} {
####     set pin_obj [mw_get_pin_port $pin]
####     set net [get_bd_nets -quiet -of_objects $pin_obj]
####     set intf_net [get_bd_intf_nets -quiet -of_objects $pin_obj]
####     set numConnections [expr [llength $net] + [llength $intf_net]]
####     if { $numConnections > 0 } {
####         return 1
####     } else {
####         return 0
####     }
#### }
#### proc mw_disconnect_pin {pin} {
####     set pin_obj [mw_get_pin_port $pin]
####     if { [mw_is_connected $pin_obj] } {
####         set net [mw_get_net_of_pin $pin_obj]
####         if {[mw_is_intf $pin_obj]} {
####             set pins [get_bd_intf_pins -quiet -of_objects $net]
####             set ports [get_bd_intf_ports -quiet -of_objects $net]
####         } else {
####             set pins [get_bd_pins -quiet -of_objects $net]
####             set ports [get_bd_ports -quiet -of_objects $net]
####         }
####         set numConnections [expr [llength $pins] + [llength $ports]]
####         if { $numConnections == 1 } {
####             delete_bd_objs $net
####         } else {
####             if {[mw_is_intf $pin_obj]} {
####                 disconnect_bd_intf_net $net $pin_obj
####             } else {
####                 disconnect_bd_net $net $pin_obj
####             }
####         }
####     }
#### }
#### proc mw_bd_set_project_defaults {} {
####     mw_project_set ipcore_clk_net [get_bd_nets sys_core_clk]
####     mw_project_set ipcore_rstn_net [get_bd_nets sys_core_resetn]
####     mw_project_set ipcore_rst_net [get_bd_nets sys_core_reset]
####     mw_project_set axi_cpu_interconnect [get_bd_cells axi_cpu_interconnect]
####     mw_project_set sys_cpu [mw_get_cpu]
####     mw_project_set sys_addr_cntrl_space [mw_get_sys_addr_cntrl_space]
#### }
#### proc mw_bd_save {} {
####     regenerate_bd_layout
####     save_bd_design
####     #removing validate_bd_design for issues with Vivado 2017.4 regarding
####     #unconnected AXI4 master connnection
####     #validate_bd_design
####     save_bd_design
#### }
## if { [llength [current_bd_design -quiet]] == 0 } {
##     set BDFILEPATH [get_files -quiet system.bd]
##     open_bd_design $BDFILEPATH
## }
## current_bd_design -quiet
Adding cell -- xilinx.com:ip:processing_system7:5.5 - sys_ps7
Adding cell -- xilinx.com:ip:axi_iic:2.0 - axi_iic_main
Adding cell -- xilinx.com:ip:xlconcat:2.1 - sys_concat_intc
Adding cell -- xilinx.com:ip:proc_sys_reset:5.0 - sys_rstgen
Adding cell -- analog.com:user:axi_ad9361:1.0 - axi_ad9361
Adding cell -- analog.com:user:util_tdd_sync:1.0 - util_ad9361_tdd_sync
Adding cell -- xilinx.com:ip:xlconcat:2.1 - util_ad9361_divclk_sel_concat
Adding cell -- xilinx.com:ip:util_reduced_logic:2.0 - util_ad9361_divclk_sel
Adding cell -- analog.com:user:util_clkdiv:1.0 - util_ad9361_divclk
Adding cell -- xilinx.com:ip:proc_sys_reset:5.0 - util_ad9361_divclk_reset
Adding cell -- analog.com:user:util_wfifo:1.0 - util_ad9361_adc_fifo
Adding cell -- analog.com:user:util_cpack:1.0 - util_ad9361_adc_pack
Adding cell -- analog.com:user:axi_dmac:1.0 - axi_ad9361_adc_dma
Adding cell -- analog.com:user:util_rfifo:1.0 - axi_ad9361_dac_fifo
Adding cell -- analog.com:user:util_upack:1.0 - util_ad9361_dac_upack
Adding cell -- analog.com:user:axi_dmac:1.0 - axi_ad9361_dac_dma
Adding cell -- xilinx.com:ip:xlconstant:1.1 - const_intr_concat_gnd
Adding cell -- mathworks.com:user:util_mw_dac_reg:1.0 - dac_latch
Adding cell -- mathworks.com:user:util_mw_bypass_user_logic:1.0 - bypass_tx
Adding cell -- mathworks.com:user:util_mw_bypass_user_logic:1.0 - bypass_rx
Adding cell -- mathworks.com:user:util_mw_gpio_mux:1.0 - gpio_mux_0
Adding cell -- mathworks.com:user:util_mw_clkconstr:1.0 - util_mw_clkconstr
Adding cell -- mathworks.com:user:util_mw_led_driver:1.0 - led_driver
Adding cell -- user.org:ip:ZynqBF_2t_ip:1.0 - ZynqBF_2t_ip_0
WARNING: [BD 41-1731] Type mismatch between connected pins: /sys_ps7/FCLK_CLK0(clk) and /led_driver/clk_ps7(undef)
WARNING: [BD 41-1731] Type mismatch between connected pins: /util_mw_clkconstr/clk_out(clk) and /led_driver/clk_rf(undef)
Adding cell -- xilinx.com:ip:axi_crossbar:2.1 - xbar
Adding cell -- xilinx.com:ip:axi_protocol_converter:2.1 - auto_pc
Adding cell -- xilinx.com:ip:axi_protocol_converter:2.1 - auto_pc
Adding cell -- xilinx.com:ip:axi_protocol_converter:2.1 - auto_pc
Adding cell -- xilinx.com:ip:axi_protocol_converter:2.1 - auto_pc
Adding cell -- xilinx.com:ip:axi_protocol_converter:2.1 - auto_pc
Adding cell -- xilinx.com:ip:axi_register_slice:2.1 - m01_regslice
Adding cell -- xilinx.com:ip:axi_clock_converter:2.1 - auto_cc
Adding cell -- xilinx.com:ip:axi_protocol_converter:2.1 - auto_pc
Adding cell -- xilinx.com:ip:axi_protocol_converter:2.1 - auto_pc
Adding cell -- xilinx.com:ip:axi_protocol_converter:2.1 - auto_pc
Successfully read diagram <system> from BD file </home/jason/matlab/Projects/hdl_prj/vivado_ip_prj/vivado_prj.srcs/sources_1/bd/system/system.bd>
## source $mw_hdl_dir/projects/ad9361/common/mw_cleanup_io.tcl
### set dac_upack_name util_ad9361_dac_upack
### set dac_fifo_name axi_ad9361_dac_fifo
### set dac_latch_name dac_latch
### set bypass_tx_name bypass_tx
### set HWNUMCHAN [get_property CONFIG.NUM_OF_CHANNELS [get_bd_cells ${dac_fifo_name}]]
### mw_create_const gnd_ad9361_dac_data 16 0
### for {set ch 0} {$ch < $HWNUMCHAN} {incr ch} {
###     if { ![mw_is_connected axi_ad9361_dac_fifo/din_data_${ch}] } {
###         mw_connect_pin axi_ad9361_dac_fifo/din_data_${ch} const_gnd_ad9361_dac_data
###     }
### }
### if { ![mw_is_connected ${dac_latch_name}/dac_valid] } {
###     mw_connect_pin ${dac_latch_name}/dac_valid ${bypass_tx_name}/mux_valid_out_0
### }
### if { ![mw_is_connected ${bypass_tx_name}/dut_valid_in] } {
###     mw_connect_pin ${bypass_tx_name}/dut_valid_in ${dac_upack_name}/dac_valid_out_0
### }
### set nValid -1
### for {set ch 0} {$ch < $HWNUMCHAN} {incr ch} {
###     # Only one valid line per every two channels (I+Q)
###     if { [expr {$ch % 2} == 0 ] } {
###         incr nValid
###         if { ![mw_is_connected ${bypass_tx_name}/bypass_valid_in_${nValid}] } {
###             mw_connect_pin ${bypass_tx_name}/bypass_valid_in_${nValid} ${dac_upack_name}/dac_valid_out_${ch}
###         }
###     }
###     if { ![mw_is_connected ${dac_fifo_name}/din_valid_in_${ch}] } {
###         mw_connect_pin ${bypass_tx_name}/mux_valid_out_${nValid} ${dac_fifo_name}/din_valid_in_${ch}
###     }
###     if { ![mw_is_connected ${bypass_tx_name}/bypass_data_in_${ch}] } {
###         mw_connect_pin ${bypass_tx_name}/bypass_data_in_${ch} ${dac_upack_name}/dac_data_${ch}
###     }
### 	if { ![mw_is_connected ${bypass_tx_name}/dut_data_in_${ch}] } {
###         mw_connect_pin ${bypass_tx_name}/dut_data_in_${ch} ${dac_upack_name}/dac_data_${ch}
###     }
###     if { ![mw_is_connected ${dac_upack_name}/dac_enable_${ch}] } {
###         mw_connect_pin ${dac_upack_name}/dac_enable_${ch} ${dac_fifo_name}/din_enable_${ch}
###     }
### }
### set adc_pack_name util_ad9361_adc_pack
### set adc_fifo_name util_ad9361_adc_fifo
### set bypass_rx_name bypass_rx
### set HWNUMCHAN [get_property CONFIG.NUM_OF_CHANNELS [get_bd_cells ${adc_fifo_name}]]
### if { ![mw_is_connected ${bypass_rx_name}/dut_valid_in] } {
###     mw_connect_pin ${adc_fifo_name}/dout_valid_0 ${bypass_rx_name}/dut_valid_in 
### }
### if { ![mw_is_connected ${bypass_rx_name}/bypass_valid_in_0] } {
###     mw_connect_pin ${adc_fifo_name}/dout_valid_0 ${bypass_rx_name}/bypass_valid_in_0 
### }
### set nValid -1 
### for {set ch 0} {$ch < $HWNUMCHAN} {incr ch} {
###     # Only one valid line per every two channels (I+Q)
###     if { [expr {$ch % 2} == 0 ] } {
###         incr nValid
###         if { ![mw_is_connected ${bypass_rx_name}/bypass_valid_in_${nValid}] } {
###             mw_connect_pin ${adc_fifo_name}/dout_valid_${ch} ${bypass_rx_name}/bypass_valid_in_${nValid}
###         }
###     }
###     if { ![mw_is_connected ${adc_pack_name}/adc_valid_${ch}] } {
###         mw_connect_pin ${adc_pack_name}/adc_valid_${ch} ${bypass_rx_name}/mux_valid_out_${nValid}
###     }
###     if { ![mw_is_connected ${adc_pack_name}/adc_data_${ch}] } {
###         mw_connect_pin ${bypass_rx_name}/mux_data_out_${ch} ${adc_pack_name}/adc_data_${ch}
###     }
###     if { ![mw_is_connected ${adc_pack_name}/adc_enable_${ch}] } {
###         mw_connect_pin ${adc_fifo_name}/dout_enable_${ch} ${adc_pack_name}/adc_enable_${ch}
###     }
### 	if { ![mw_is_connected ${bypass_rx_name}/bypass_data_in_${ch}] } {
###         mw_connect_pin ${adc_fifo_name}/dout_data_${ch} ${bypass_rx_name}/bypass_data_in_${ch}
###     }
### 	if { ![mw_is_connected ${bypass_rx_name}/dut_data_in_${ch}] } {
###         mw_connect_pin ${adc_fifo_name}/dout_data_${ch} ${bypass_rx_name}/dut_data_in_${ch}
###     }
### }
### set MW_GPIO_BYPASS 4
### foreach gpio_mux [get_bd_cells -quiet gpio_mux*] {
###     set mux_name [get_property Name $gpio_mux]
###     set nports [get_property CONFIG.NUM_PORTS $gpio_mux]
###     for {set idx 0} {$idx < $nports} {incr idx} {
###         if { !([mw_is_connected ${mux_name}/port_${idx}_i] || 
###             [mw_is_connected ${mux_name}/port_${idx}_o]) } {
###             # Unused, set to default state
###             set_property CONFIG.PORT_${idx}_TYPE $MW_GPIO_BYPASS $gpio_mux
###         }
###     }
### }
### mw_cleanup_orphan_nets
Deleting orphan net /const_gnd_ad9361_dac_data
## source $mw_hdl_dir/projects/ad9361/common/mw_cleanup_bd_gpio.tcl
WARNING: [BD 5-236] No ports matched 'get_bd_ports GPLEDs'
### set LEDPort [get_bd_ports GPLEDs]
WARNING: [BD 5-236] No ports matched 'get_bd_ports DIPSwitches'
### set DIPPort [get_bd_ports DIPSwitches]
WARNING: [BD 5-236] No ports matched 'get_bd_ports PushButtons'
### set PBPort  [get_bd_ports PushButtons]
### set hasPBs  0
### set hasDIPs 0
### set hasLEDs 0
### if { $LEDPort ne ""} { set hasLEDs 1 }
### if { $DIPPort ne ""} { set hasDIPs 3 }
### if { $PBPort  ne ""} { set hasPBs  9 }
### if { $hasLEDs || $hasDIPs || $hasPBs } {
### 
###     set ioSum [expr {$hasLEDs + $hasDIPs + $hasPBs}]
###     if { $boardName == "zed" } {
###         set LED_OFFSET 19
###         set DIP_OFFSET 11
###         set PB_OFFSET  0
###         set LED_WIDTH  7
###         set DIP_WIDTH  8
###         set PB_WIDTH   5
###         if { $ioSum == 13 } {
###             set ioBufStr1 "    .dio_t ({gpio_t[50:49], gpio_t[46:27], gpio_t[10:5]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[50:49], gpio_o[46:27], gpio_o[10:5]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[50:49], gpio_i[46:27], gpio_i[10:5]}),"
###             set ioBufStr4 "              gpio_bd[31:27], gpio_bd[10:5]\}));"
###         } elseif { $ioSum == 12 } {
###             set ioBufStr1 "    .dio_t ({gpio_t[50:49], gpio_t[46:27], gpio_t[25:19], gpio_t[10:5]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[50:49], gpio_o[46:27], gpio_o[25:19], gpio_o[10:5]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[50:49], gpio_i[46:27], gpio_i[25:19], gpio_i[10:5]}),"
###             set ioBufStr4 "              gpio_bd[31:27], gpio_bd[25:19], gpio_bd[10:5]\}));"
###         } elseif { $ioSum == 10 } {
###             set ioBufStr1 "    .dio_t ({gpio_t[50:49], gpio_t[46:27], gpio_t[18:5]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[50:49], gpio_o[46:27], gpio_o[18:5]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[50:49], gpio_i[46:27], gpio_i[18:5]}),"
###             set ioBufStr4 "              gpio_bd[31:27], gpio_bd[18:5]\}));"
###         } elseif { $ioSum == 9  } {
###             set ioBufStr1 "    .dio_t ({gpio_t[50:49], gpio_t[46:27], gpio_t[25:5]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[50:49], gpio_o[46:27], gpio_o[25:5]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[50:49], gpio_i[46:27], gpio_i[25:5]}),"
###             set ioBufStr4 "              gpio_bd[31:27], gpio_bd[25:5]\}));"
###         } elseif { $ioSum == 4  } {
###             set ioBufStr1 "    .dio_t ({gpio_t[50:49], gpio_t[46:27], gpio_t[10:0]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[50:49], gpio_o[46:27], gpio_o[10:0]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[50:49], gpio_i[46:27], gpio_i[10:0]}),"
###             set ioBufStr4 "              gpio_bd[31:27], gpio_bd[10:0]\}));"
###         } elseif { $ioSum == 3  } {
###             set ioBufStr1 "    .dio_t ({gpio_t[50:49], gpio_t[46:27], gpio_t[25:19], gpio_t[10:0]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[50:49], gpio_o[46:27], gpio_o[25:19], gpio_o[10:0]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[50:49], gpio_i[46:27], gpio_i[25:19], gpio_i[10:0]}),"
###             set ioBufStr4 "              gpio_bd[31:27], gpio_bd[25:19], gpio_bd[10:0]\}));"
###         } elseif { $ioSum == 1  } {
###             set ioBufStr1 "    .dio_t ({gpio_t[50:49], gpio_t[46:27], gpio_t[18:0]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[50:49], gpio_o[46:27], gpio_o[18:0]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[50:49], gpio_i[46:27], gpio_i[18:0]}),"
###             set ioBufStr4 "              gpio_bd[31:27], gpio_bd[18:0]\}));"
###         }  
###     } elseif { $boardName == "zc706" } {
###         if { $project == "fmcomms2" } { 
###             set startBit 14 
###         } elseif { $project == "fmcomms5" } { 
###             set startBit 59 
###         }
###         set LED_OFFSET 7
###         set DIP_OFFSET 0
###         set PB_OFFSET  4
###         set LED_WIDTH  3
###         set DIP_WIDTH  4
###         set PB_WIDTH   3
###         if { $ioSum == 13 } {
###             set ioBufStr1 "    .dio_t (gpio_t[$startBit:11]),"
###             set ioBufStr2 "    .dio_i (gpio_o[$startBit:11]),"
###             set ioBufStr3 "    .dio_o (gpio_i[$startBit:11]),"
###             set ioBufStr4 "            gpio_bd[14:11]));"
###         } elseif { $ioSum == 12 } {
###             set ioBufStr1 "    .dio_t ({gpio_t[$startBit:11], gpio_t[9:7]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[$startBit:11], gpio_o[9:7]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[$startBit:11], gpio_i[9:7]}),"
###             set ioBufStr4 "            gpio_bd[$14:11], gpio_bd[9:7]\}));"
###         } elseif { $ioSum == 10 } {
###             set ioBufStr1 "    .dio_t ({gpio_t[$startBit:11], gpio_t[3:0]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[$startBit:11], gpio_o[3:0]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[$startBit:11], gpio_i[3:0]}),"
###             set ioBufStr4 "            gpio_bd[14:11], gpio_bd[3:0]\}));"
###         } elseif { $ioSum == 9  } {
###             set ioBufStr1 "    .dio_t ({gpio_t[$startBit:11], gpio_t[9:7], gpio_t[3:0]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[$startBit:11], gpio_o[9:7], gpio_o[3:0]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[$startBit:11], gpio_i[9:7], gpio_i[3:0]}),"
###             set ioBufStr4 "            gpio_bd[14:11], gpio_bd[9:7], gpio_bd[3:0]\}));"
###         } elseif { $ioSum == 4  } {
###             set ioBufStr1 "    .dio_t ({gpio_t[$startBit:11], gpio_t[6:4]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[$startBit:11], gpio_o[6:4]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[$startBit:11], gpio_i[6:4]}),"
###             set ioBufStr4 "            gpio_bd[14:11], gpio_bd[6:4]\}));"
###         } elseif { $ioSum == 3  } {
###             set ioBufStr1 "    .dio_t ({gpio_t[$startBit:11], gpio_t[9:4]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[$startBit:11], gpio_o[9:4]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[$startBit:11], gpio_i[9:4]}),"
###             set ioBufStr4 "            gpio_bd[14:11], gpio_bd[9:4]\}));"
###         } elseif { $ioSum == 1  } {
###             set ioBufStr1 "    .dio_t ({gpio_t[$startBit:11], gpio_t[6:0]}),"
###             set ioBufStr2 "    .dio_i ({gpio_o[$startBit:11], gpio_o[6:0]}),"
###             set ioBufStr3 "    .dio_o ({gpio_i[$startBit:11], gpio_i[6:0]}),"
###             set ioBufStr4 "            gpio_bd[14:11], gpio_bd[6:0]\}));"
###         }  
###     } elseif { $boardName == "ccfmc_lvds" } {
###         set LED_OFFSET 5
###         set DIP_OFFSET 8 
###         set PB_OFFSET  0
###         set LED_WIDTH  3
###         set DIP_WIDTH  4 
###         set PB_WIDTH   4
###         if { $ioSum == 13 } {
###             set ioBufStr1 "   .dio_t (gpio_t[20:12]),"
###             set ioBufStr2 "   .dio_i (gpio_o[20:12]),"
###             set ioBufStr3 "   .dio_o (gpio_i[20:12]),"
###             set ioBufStr4 "   .dio_p (gpio_bd[20:12]));"
###         } elseif { $ioSum == 12 } {
###             set ioBufStr1 "   .dio_t ({gpio_t[20:12], gpio_t[7:5]}),"
###             set ioBufStr2 "   .dio_i ({gpio_o[20:12], gpio_o[7:5]}),"
###             set ioBufStr3 "   .dio_o ({gpio_i[20:12], gpio_i[7:5]}),"
###             set ioBufStr4 "   .dio_p ({gpio_bd[20:12], gpio_bd[7:5]}));"
###         } elseif { $ioSum == 10 } {
###             set ioBufStr1 "   .dio_t (gpio_t[20:8]),"
###             set ioBufStr2 "   .dio_i (gpio_o[20:8]),"
###             set ioBufStr3 "   .dio_o (gpio_i[20:8]),"
###             set ioBufStr4 "   .dio_p (gpio_bd[20:8]));"
###         } elseif { $ioSum == 9  } {
###             set ioBufStr1 "   .dio_t (gpio_t[20:5]),"
###             set ioBufStr2 "   .dio_i (gpio_o[20:5]),"
###             set ioBufStr3 "   .dio_o (gpio_i[20:5]),"
###             set ioBufStr4 "   .dio_p (gpio_bd[20:5]));"
###         } elseif { $ioSum == 4  } {
###             set ioBufStr1 "   .dio_t ({gpio_t[20:12], gpio_t[3:0]}),"
###             set ioBufStr2 "   .dio_i ({gpio_o[20:12], gpio_o[3:0]}),"
###             set ioBufStr3 "   .dio_o ({gpio_i[20:12], gpio_i[3:0]}),"
###             set ioBufStr4 "   .dio_p ({gpio_bd[20:12], gpio_bd[3:0]}));"
###         } elseif { $ioSum == 3  } {
###             set ioBufStr1 "   .dio_t ({gpio_t[20:12], gpio_t[7:5], gpio_t[3:0]}),"
###             set ioBufStr2 "   .dio_i ({gpio_o[20:12], gpio_o[7:5], gpio_o[3:0]}),"
###             set ioBufStr3 "   .dio_o ({gpio_i[20:12], gpio_i[7:5], gpio_i[3:0]}),"
###             set ioBufStr4 "   .dio_p ({gpio_bd[20:12], gpio_bd[7:5], gpio_bd[3:0]}));"
###         } elseif { $ioSum == 1  } {
###             set ioBufStr1 "   .dio_t ({gpio_t[20:8], gpio_t[3:0]}),"
###             set ioBufStr2 "   .dio_i ({gpio_i[20:8], gpio_i[3:0]}),"
###             set ioBufStr3 "   .dio_o ({gpio_o[20:8], gpio_o[3:0]}),"
###             set ioBufStr4 "   .dio_p ({gpio_bd[20:8], gpio_bd[3:0]}));"
###         }  
###     }
###     
###     set dutConstrFile [ get_files -of [get_filesets {constrs_1}] ]
###     remove_files -fileset constrs_1 $dutConstrFile
### 
###     set firstLED $LED_OFFSET
###     set lastLED [ expr {$LED_OFFSET + $LED_WIDTH - 1} ]
###     set firstDIP $DIP_OFFSET
###     set lastDIP [ expr {$DIP_OFFSET + $DIP_WIDTH - 1} ]
###     set firstPB  $PB_OFFSET
###     set lastPB  [ expr {$PB_OFFSET + $PB_WIDTH - 1} ]
###     
###     set ledStr ""
###     set dipStr ""
###     set pbStr  ""
###     set dw 0
###     set minOff 0
###     set maxOff 0
###     # Create insertion string, and calculate required GPIO datawidth
###     if { $hasLEDs } { 
###         set ledStr "    .GPLEDs (gpio_bd[$lastLED:$firstLED]),\n" 
###         set dw [ expr { $dw + $LED_WIDTH } ]
###     }
###     if { $hasDIPs } { 
###         set dipStr "    .DIPSwitches (gpio_bd[$lastDIP:$firstDIP]),\n" 
###         set dw [ expr { $dw + $DIP_WIDTH } ]
###     }
###     if { $hasPBs } { 
###         set pbStr "    .PushButtons (gpio_bd[$lastPB:$firstPB]),\n"
###         set dw [ expr { $dw + $PB_WIDTH } ]
###     }
###     set insertStr $ledStr$dipStr$pbStr 
###  
###     # find system_top.v
###     set foundIOBuf 0
###     set sysTop [ get_files system_top.v ]
###     set topF [ open $sysTop r+ ]
###     set newTop [ open $sysTop.new w ]
###     while {[gets $topF line] >= 0} {
###         if { [string first "system_wrapper i_system_wrapper" $line] != -1 } {
###              puts $newTop $line 
###              puts $newTop $insertStr
###         } elseif { [string first "i_iobuf_bd" $line] != -1 } {
###              regexp {[0-9]+} $line oldDw
###              set newDW [ expr { $oldDw - $dw } ]
###              set newLine "   ad_iobuf #(.DATA_WIDTH($newDW)) i_iobuf_bd ("
###              puts $newTop $newLine
###              set foundIOBuf 1
###         } elseif { [string first ", gpio_t" $line] != -1 &&  $foundIOBuf == 1 } {
###             puts $newTop $ioBufStr1 
###         } elseif { [string first ", gpio_i" $line] != -1 &&  $foundIOBuf == 1 } {
###             puts $newTop $ioBufStr2 
###         } elseif { [string first ", gpio_o" $line] != -1 &&  $foundIOBuf == 1 } {
###             puts $newTop $ioBufStr3
###         } elseif { [string first "gpio_bd" $line] != -1 &&  $foundIOBuf == 1 } {
###             puts $newTop $ioBufStr4
###             set foundIOBuf 0
###         } else {
###             puts $newTop $line
###         }
###     }
###     close $newTop
###     close $topF
### 
###     file rename -force $sysTop $sysTop.old
###     file rename -force $sysTop.new $sysTop
### }
## validate_bd_design
WARNING: [#UNDEF] When using EMIO pins for SPI_0 tie SSIN High in the PL bitstream
WARNING: [#UNDEF] When using EMIO pins for SPI_1 tie SSIN High in the PL bitstream
WARNING: [BD 41-927] Following properties on pin /axi_ad9361/delay_clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_sys_ps7_0_FCLK_CLK1 
WARNING: [BD 41-927] Following properties on pin /axi_ad9361/l_clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_axi_ad9361_0_l_clk 
WARNING: [BD 41-927] Following properties on pin /axi_ad9361/clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_axi_ad9361_0_l_clk 
WARNING: [BD 41-927] Following properties on pin /axi_ad9361/s_axi_aclk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_sys_ps7_0_FCLK_CLK0 
WARNING: [BD 41-927] Following properties on pin /util_ad9361_tdd_sync/clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_sys_ps7_0_FCLK_CLK0 
WARNING: [BD 41-927] Following properties on pin /util_ad9361_divclk/clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_axi_ad9361_0_l_clk 
WARNING: [BD 41-927] Following properties on pin /util_ad9361_divclk/clk_out have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_ad9361_divclk_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /util_ad9361_adc_fifo/din_clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_axi_ad9361_0_l_clk 
WARNING: [BD 41-927] Following properties on pin /util_ad9361_adc_fifo/dout_clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /util_ad9361_adc_pack/adc_rst have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	POLARITY=ACTIVE_HIGH 
WARNING: [BD 41-927] Following properties on pin /util_ad9361_adc_pack/adc_clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /axi_ad9361_dac_fifo/din_clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /axi_ad9361_dac_fifo/dout_clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_axi_ad9361_0_l_clk 
WARNING: [BD 41-927] Following properties on pin /util_ad9361_dac_upack/dac_clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /dac_latch/clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /bypass_tx/IPCORE_CLK have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /bypass_tx/AXI4_Lite_ACLK have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_sys_ps7_0_FCLK_CLK0 
WARNING: [BD 41-927] Following properties on pin /bypass_rx/IPCORE_CLK have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /bypass_rx/AXI4_Lite_ACLK have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_sys_ps7_0_FCLK_CLK0 
WARNING: [BD 41-927] Following properties on pin /util_mw_clkconstr/clk have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_ad9361_divclk_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /util_mw_clkconstr/clk_out have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /led_driver/rst have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	POLARITY=ACTIVE_HIGH 
WARNING: [BD 41-927] Following properties on pin /ZynqBF_2t_ip_0/IPCORE_CLK have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
WARNING: [BD 41-927] Following properties on pin /ZynqBF_2t_ip_0/AXI4_Lite_ACLK have been updated from connected ip. They may not be synchronized with cell properties. You can set property on pin directly to confirm the value and resolve the warning.
	CLK_DOMAIN=system_util_mw_clkconstr_0_clk_out 
## save_bd_design
Wrote  : </home/jason/matlab/Projects/hdl_prj/vivado_ip_prj/vivado_prj.srcs/sources_1/bd/system/system.bd> 
## source $mw_hdl_dir/projects/ad9361/common/gen_wrapper.tcl
### set BDFILEPATH [get_files -quiet system.bd]
### make_wrapper -files $BDFILEPATH -top
INFO: [BD 41-1662] The design 'system.bd' is already validated. Therefore parameter propagation will not be re-run.
VHDL Output written to : /home/jason/matlab/Projects/hdl_prj/vivado_ip_prj/vivado_prj.srcs/sources_1/bd/system/synth/system.v
VHDL Output written to : /home/jason/matlab/Projects/hdl_prj/vivado_ip_prj/vivado_prj.srcs/sources_1/bd/system/sim/system.v
VHDL Output written to : /home/jason/matlab/Projects/hdl_prj/vivado_ip_prj/vivado_prj.srcs/sources_1/bd/system/hdl/system_wrapper.v
### regsub -all "system.bd" [get_files -quiet system.bd] "hdl/system_wrapper.v" TOPFILEPATH
### catch {
###         add_files -norecurse $TOPFILEPATH
###         update_compile_order -fileset sources_1
###         }
### regsub -all "system.bd" [get_files -quiet system.bd] "hdl/system_wrapper.vhd" TOPFILEPATH
### catch {
###         add_files -norecurse $TOPFILEPATH
###         update_compile_order -fileset sources_1
###         }
# close_project
# exit
INFO: [Common 17-206] Exiting Vivado at Tue Jan 15 11:07:35 2019...
